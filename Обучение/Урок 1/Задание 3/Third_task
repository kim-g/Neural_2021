import numpy as np
import matplotlib.pyplot as plt
from tensorflow import keras
from tensorflow.keras.layers import Dense,Dropout
from random import randint

#генератор

xy = set()
while len(xy) < 4000:
  a = (randint(-2000, 2000), randint(-2000, 2000))
  if a[1] == a[0]*1.5-3 or a[1] == a[0]*-0.5+2:
     continue
  xy.add(a)#генерируем значения кординат
xy = np.array(list(xy))
answer = []
for x in xy :
   if -2<=x[1]<=0 :
       x_in_equation = ((x[1]+2)*0.5)**0.5
       if x_in_equation >= 0:
           if x[0] >= x_in_equation:
               answer.append(1)
           else:
               answer.append(0)
       if x_in_equation < 0:
           if x[0] > x_in_equation:
               answer.append(1)
           else:
               answer.append(0)
   else:
       answer.append(0)
answer=np.array(answer)#генерируем ответы исходя из xy(всё от 13 строки)
print(xy,answer)

#нс

model=keras.Sequential([
   Dense(2, input_shape=(2,), activation='relu'),
   Dense(3, input_shape=(2,), activation='relu'),
   Dense(1, input_shape=(2,), activation='softmax'),
])#создаём стопку слоёв из 2-ух слоёв с 2-мя входами
model.compile(loss='mean_squared_error', optimizer = keras.optimizers.Adam(0.1))# модель нс
history = model.fit( x=xy, y=answer, epochs = 2000, verbose=False)#обучаем
plt.plot(history.history['loss'])
plt.grid(True)
plt.show#выводим график
print(model.get_weights())#выводим веса
print(model.summary())

#ввод

inp = list(map(int, input().split()))
for num1, num2 in zip(inp[::2], inp[1::2]): #ввод значений
   print(np.round(model.predict(np.array([[num2 ,num1]]))),model.predict(np.array([[num2 ,num1]])))
